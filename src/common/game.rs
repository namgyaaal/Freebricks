use crate::{
    common::{asset_cache::AssetCache, model_graph::*, state::State},
    ecs::{common::*, parts::*, physics::*},
    physics::PhysicsState,
    render::{
        camera::Camera,
        debug_draw::DebugDraw,
        render_state::{RenderOptions, RenderPassInfo, RenderState},
        scene_tree::SceneTree,
    },
};
use anyhow::Result;
use bevy_ecs::prelude::*;
use glam::Vec3;
use std::sync::Arc;
use tracing::error;
use winit::{dpi::PhysicalSize, window::Window};

#[derive(Component)]
pub struct Tag1;

pub fn foobar(mut commands: Commands, mut count: Local<u64>, test: Query<(Entity, &Tag1)>) {
    if *count == 140 {
        let (e, _) = test.iter().next().unwrap();
        commands.entity(e).despawn();
    }
    *count += 1;
}

pub struct Game {
    //pub render_state: RenderState,
    pub world: World,
    pub update: Schedule,
    pub post_update: Schedule,
    pub render: Schedule,
}

impl Game {
    pub async fn new(window: Arc<Window>) -> Result<Self> {
        let render_state = RenderState::new(window.clone(), RenderOptions::RenderTimestamps.into())
            .await
            .expect("Game::new(), couldn't create Render State");

        let mut world = World::new();

        let asset_cache = AssetCache::init("assets").expect("Unable to load from asset directory");

        world.insert_resource(asset_cache);

        let physics_state = PhysicsState::new();
        let mut init_schedule = Schedule::default();
        let mut update_schedule = Schedule::default();

        let mut post_update_schedule = Schedule::default();
        let mut render_schedule = Schedule::default();

        RenderState::consume(&mut world, render_state);
        PhysicsState::consume(&mut world, physics_state);

        world.add_observer(handle_part_of_model_deletion);
        /*
            Game scene updating.

        */

        init_schedule.add_systems(
            (
                Camera::init,
                SceneTree::init,
                DebugDraw::init,
                build_models,
                PhysicsState::setup_system(),
            )
                .chain(),
        );
        update_schedule.add_systems((foobar,).chain());

        post_update_schedule.add_systems(
            (
                handle_model_transform,
                PhysicsState::update_system(true),
                SceneTree::remove_bricks,
                SceneTree::add_bricks,
                SceneTree::update_bricks,
            )
                .chain(),
        );

        render_schedule.add_systems((
            SceneTree::render.before(RenderState::flush),
            DebugDraw::render.before(RenderState::flush),
            RenderState::flush,
        ));

        // Do anything here
        let mut parts = Vec::new();
        world.spawn((
            Part::default(),
            Position(Vec3::new(0.0, -7.0, 0.0)),
            Size(Vec3::new(20.0, 1.0, 20.0)),
            Physical,
            Anchor,
            Tag1,
        ));

        parts.push((
            Part::default(),
            Position(Vec3::new(0.0, -10.0, 0.0)),
            Physical,
            Color([rand::random(), rand::random(), rand::random(), 255]),
        ));

        parts.push((
            Part::default(),
            Position(Vec3::new(0.0, -8.0, 0.0)),
            Physical,
            Color([rand::random(), rand::random(), rand::random(), 255]),
        ));
        /*
        parts.push((
            Part::default(),
            Position(Vec3::new(0.0, -7.0, 0.0)),
            Physical,
            Color([rand::random(), rand::random(), rand::random(), 255]),
        ));
        */
        parts.push((
            Part::default(),
            Position(Vec3::new(0.0, -11.0, 0.0)),
            Physical,
            Color([rand::random(), rand::random(), rand::random(), 255]),
        ));

        world.spawn((
            Part::default(),
            Position(Vec3::new(0.0, -9.0, 0.0)),
            Physical,
            Color([rand::random(), rand::random(), rand::random(), 255]),
        ));

        let _ = world.spawn_batch(parts).collect::<Vec<Entity>>();

        // Initialize states and globals, don't need it further and we only pass on update and render
        init_schedule.run(&mut world);
        Ok(Self {
            world: world,
            update: update_schedule,
            post_update: post_update_schedule,
            render: render_schedule,
        })
    }

    pub fn resize(&mut self, size: PhysicalSize<u32>) -> Result<()> {
        let mut state = self.world.get_resource_mut::<RenderState>().unwrap();

        state.resize(size.width, size.height);
        Ok(())
    }

    pub fn update(&mut self) {
        // Update
        self.update.run(&mut self.world);
        self.post_update.run(&mut self.world);

        // We don't really need to do ECS for rendering, all relevant information should be passed to proper globals
        // e.g., ResMut<SceneTree> should have buffers generated by now here.
        let mut state = self.world.get_resource_mut::<RenderState>().unwrap();
        match state.begin_pass() {
            Ok(None) => {}
            Ok(Some(new_info)) => {
                let mut info = self.world.get_resource_mut::<RenderPassInfo>().unwrap();

                *info = new_info;
                self.render.run(&mut self.world);
            }
            Err(e) => {
                error!("Error rendering: {e}");
            }
        }

        self.world.clear_trackers();
    }
}
